\begin{notes}
    \item Netzwerkaufbau
    \begin{notes}
        \item Edge Computing (zentrale Verwaltung)
        \item Fog Computing (lokale Fahrzeuge schließen sich zu Rehchenknoten zusammen)
        \item “a horizontal system-level architecture that distributes computing, storage, and networking functions closer to the user along a cloud-to-thing continuum”  OpenFog Consortium (Group, O.C.A.W., et al.: Openfog reference architecture for fog computing. OPFRA001 20817, 162 (2017))
        \item Mist Computing
    \end{notes}
    \item Kommunikation
    \begin{notes}
        \item Zertifikate (Public/Private Key)
        \item identitätsverschlüsselung
        \item Belohnung für bereitgestellte Rechenleistung
    \end{notes}
    \item Resourcenverteilung
    \begin{notes}
        \item Bestimmung der verfügbaren Rechenleistung 
        \item Optimierungsalgorythmen
        \item Stackelberg Model
    \end{notes}
    \item Publish Subscribe
    \begin{notes}
        \item 
        \item Optimierungsalgorythmen
        \item Stackelberg Model
    \end{notes}
    \item Softwarearchitektur in Fahrzeugen
   \begin{notes}
        \item RTOS
        \item Middle Layer (ROS, keine automotive alternative stand 2019)
        \item Cloud
    \end{notes}
\end{notes}

\begin{notes}
\item Stand der Technik
    \begin{notes}
        \item Cloud Computing
        \begin{notes}
            \item IT resourcen werden flexibel nach Bedarf zur Verfügung bereitgestellt
            \item Realisiert durch Rechenzentren, Kunden können Resourcen mieten anstatt eigene Server betreiben
            \item Resourcen sind von verschiednen Endgeräten erreichbar \cite{Sunyaev2020}
            \item Cloud kann öffentlich oder privat sein, privat für sensible Daten \cite{Ibrahim2021}
        \end{notes}
        \item \gls{IoT} (IoT) 
        \begin{notes}
            \item Internet of Things (Internet der Dinge) bezeichnet eindeutig identifizierbare Objekte und deren virtuelle repräsentation in interent-ähnliche Strukturen\cite{Jie2013} 
            \item IoT findet mittlerweile in fast allen Bereichen Anwendung
            \item Industrie: Produktionsanlagen, die durch vernetzte Systeme flexibel angepasst werden können (Beispiel: Produktvarianten)
            \item Smart Home: Sensoren und Aktoren im Haus vernetzen \cite{Wortmann2015}
        \end{notes}
        \item Edge Computing
        \begin{notes}
            \item Daten entstehen in Endgeräten, Applikationen, die die Daten verarbeiten sind zunehmend ebenfalls in Endgeräten
            \item Beispiel Flugzeuge oder autonome Fahrzeuge, generieren Daten in Größe von mehreren Gb pro Senkunde \cite{Liu2019}
            \item Traditionell werden Daten in der Cloud ausgewertet und wieder an den Benutzer zur Verfügung gestellt, diese ist aber mit zusätzlichem Resourcenaufwand verbunden wegen lange Übertragungsstrecken. \cite{Perez2022} 
            \item Übertragung und Verarbeitung in der Cloud langsam/unmöglich wegen Bandbreite und Latenz
            \item Edge Computing ist das Konzept, dass anstatt zentrale Cloud Server, Daten zunehmend auf Endgeräten verarbeitet werden \cite{Shi2016}
            \item Edge bezeichnet Geräte zwischen Datenquellen und cloud server
            \item “a form of distributed computing in which processing and storage takes place on a set of networked machines which are near the edge, where the nearness is defined by the system’s requirements”  (ISO/IEC: Tr 30164:2020 - internet of things (iot) -edge computing. Tech. rep., ISO/IEC (2020))
            \item Motivation: Latenzreduzierung, unbenutzte Resourcen verwenden
            \item Anwendungsfälle:
            \begin{notes}
                \item Cloud Berechnungen auslagern
                \item Smart Home, Daten lokal auswerten statt alles in die Cloud laden
                \item Smart City
            \end{notes}
        \end{notes}
        \item Fog Computing
        \begin{notes} 
            \item Fog Computing: Eine Form von Edge Computing, zusätzliche Schicht zwischen Endgeräte und Cloud
            \item Edge Geräte kommunizieren mit Fog nodes, die wiederrum für die Kommunikation zwishen Edge und Cloud zuständig sind
            \item Fog nodes übernehmen Datenverarbeitung lokal, für nur Lokal benötigte Daten, Leiten nur relevante Daten an Cloud weiter
            \item Fog nodes können PC-s, raspberry PI-s, nano-server, micro-datenzentren sein. \cite{Mahmud2020}
            \item Beispiele:
            \begin{notes} 
                \item Iot for All
                \item FogFlow
            \end{notes}
        \end{notes}
        \item Mist Computing
        \begin{notes} 
            \item Datenverarbeitung direkt im Sensor.
            \item Erlaubt z.b. einfache Monitoringfunktionen direkt im Sensor
            \item Reduktion von benörigte Bandbreite und Rechenleistung in den übergeordneten Geräten
        \end{notes}
        \item Herausforderungen:
        \begin{notes}
            \item allgemeine Rechenaufgaben auf spezialisierte Hardware
            \item Erkennung von Edge nodes
            \item Effiziente identifikation bei der großen und sich dynamischen ändernden Anzahl an Geräten
            \item Task auslagerung und Verteilung
            \item Keine Beeinträchtigumg der Funktionalität des Edge Gerätes (z.b. Überlastung)
            \item Sicherheit
        \end{notes}
        \item Anwendungsfälle für Fahrzeuge:
            \begin{notes}
                \item Unbenutzte Rechenleistung von Hardware nutzen, autonome Fahrzeugen haben leistungsfähige Steuergeräte
                \item Auslagerung von Rechenaufgaben auf Fahrzeuge in der Umgebung mit freier Rechenkapazitäten
                \item Ausnutzung von Rechenleistung parkende Fahrzeuge
                \item Möglichkeit, die unbenutzte Rechenleistung zu Vermieten (wie cloud service)
            \end{notes}
        \item Publish/Subscribe Kommunikation:
            \begin{notes}
                \item Modell für Nachrichtenbasierte Kommunikation \cite{MadeWirawan2018}
                \item Ereignisbasierte Kommunikation
                \item Teilnehmer kommunizieren indem sie Nachrichten mit bestimmte Themen veröffentlichen (Publisher), Empfänger können Themen abonnieren (Subscriber) und bekommen nur die abonnierte Nachrichten
                \item Kommunikation ist anonym
                \item Komponenten: Publisher, Broker, Subscriber
                \item Broker stellt Verbindungen zwischen Publisher und Subscriber her
                \item Broker speichert die Subscriptions (Abos)
                \item Weit verbreitete Implementierung: MQTT
                \item RTPS:
                \begin{notes}
                    \item Real Time Publish Subscribe
                    \item Kommunikation erfolgt ebenfalls über Themen
                    \item Kein Broker, Teilnehmeridentifizierung erfolgt zur Laufzeit dezentralisiert
                    \item Quality of Service parameter: Reliable writer speichert Sequenznummer der Nachrichten und kann erneut versenden bei Übertraugungsfehler, Best effort Writer hat diese Funktionalität nicht
                    \item Heartbeat message: writer gibt die verfügbaren nachrichten ID-s and
                    \item AckNack message: kommunikation von empfangenen und nicht erhaltenen Nachrichten
                \end{notes}
            \end{notes}
    \end{notes}
    \item Konzept UNICARagil:
        \begin{notes}
            \item Modulare Systemarchitektur in allen Domänen 
            \item Fahrzeuge können flexibel auf verschiedene Anwendungen angepasst werden: Taxi, Privatfahrzeug, Shuttle, Cargo
            \item gemeinsamer mechanischer Platform
            \item Sensoren und Aktoren mit definierte Schnittstellen
            \item Alle Fahrzeuge vernetzt: untereinander, zur Cloud, Infobiene, Benutzer 
        \end{notes}
    \item Motivation:
    \begin{notes}
        \item Zunehmende digitalisierung in Arbeits- und Privatumfeld
        \item Cloud Dienste bereits sehr verbreitet
        \item steigende Zahl an vernetzte Endgeräte
        \item Daten entstehen an Endgeräten, verarbeitete Daten werden ebenfalls an Endgeräten benötigt
        \item Cloud basierte ansätze erfordern immer höhere Bandbreite und zentralisierte Rechenleistung
        \item Endgeräte haben immer höhere Rechenleistung, die oft unbenutzt bleibt
        \item So auch in Fahrzeugen, die wegen autonome Fahrfunktionen deutlich mehr rechenleistung bekommen
        \item Ungenutze Rechenleistung kann für externe Anwendungen zur verfügung gestellt werden
        \item Dezentralisierte Rechenleistung verringert physikalische Distanz zwischen Entstehung und Verarbeitung der Daten
        \item Einsparung an Bandbreite und zusätzliche Server Rechenleistung
    \end{notes}

    \item Konzept:
    \begin{notes}
        \item Applikation Architektur:
        \begin{notes}
            \item monolithische Architektur
            \begin{notes}
                \item Applikation beinhaltet alle operationen
                \item die gleiche Applikation kann mehrfach ausgeführt werden für parallele berechnungen
            \end{notes}
            \item Verteilt:
            \begin{notes}
                \item Modulbasiert:

                    \item Applikation auf Module aufgeteilt, abhängig voneinander
                    \item Bedienen Daten von einer Quelle
 
                \item Micro-Services:
                    \item Applikation setzt sich aus unabhängigen Prozessen zusammen
                    \item Ein Microservice erfüllt nur eine Aufgabe
            \end{notes}
        \end{notes}
        \item Applikation Platzierung:
        \begin{notes}
            \item Bestimmung verfügbare Rechenresourcen:
            \begin{notes}
                \item Profilierung: Applikation wird auf jedem Node ausgeführt, Rechenleistung wird aus Ausführungszeit bestimmt
                \item Prädiktiv: Rechenleistung wird aus vergangenen Berechnungen ermittelt
                \item Nach Bedarf: Je nach Erwartungen der Benutzer und Anforderungen an die Ausführungszeit wird nach Profil oder Prädiktiv verteilt
            \end{notes}
            \item Offloading Methoden:
            \begin{notes}
                \item Bottom-Up: Edge Geräte verlagern Applikationen in die Node Server
                \item Top-Down: Applikationen aus der Cloud oder Fog Node werden in Edge Geräte ausgelagert
                \item Hybrid: Top-Down, Bottom-Up, Edge geräte können Applikationen direkt untereinander austauschen
            \end{notes}
            \item Resourcenorientierung -Netzwerkstruktur
            \begin{notes}
                \item Hierarchie: Fog node server sind in Hierarchieebenen eingeteilt. Anzahl der Nodes auf einer Ebene nimmt nach unten hin zu. 
                \item Cluster: Fog nodes sind alle untereinander verbunden. Edge geräte werden in jeweilige Cluster gruppiert. Bessere horizontale Skalierung als bei Hierarchie.
                \item Client-Server: Einige Fog Nodes funktionieren als Server, die anderen als client. Client nodes leiten ihre daten an den server weiter.
                \item Master-Slave: Master node verteilt daten an slave nodes. Verwaltet die slave nodes. Master node kommuniziert die Ergebnisse.
            \end{notes}
            \item Mapping:
            \begin{notes}
                \item Prioritätsbasiert: Priorisiert app platzierung auf bestimmte fog nodes, meistens heuristische methoden (best fit, first fit). 
                \item Optimierung: Kostenfunktion für die optimale Aufteilung erstellen und optimieren
                \item multi-objective trade-off: nach mehreren Anforderungen gleichzeitig optimieren wie Energieverbrauch, verfügbarkeit, kosten
            \end{notes}
            \item Platzierung
            \begin{notes}
                \item Statisch: 
                \item dynamischen
                \item Ereignisbasiert
            \end{notes}
        \end{notes}
        \item Applikationsverwaltung:
        \begin{notes}
            \item t
        \end{notes}
    \end{notes}
    \item Security:
    \begin{notes}
        \item Container:
        \begin{notes}
            \item Abstraktionsebene zwischen Prozesse und OS
            \item Packt die Prozesse und deren Abhängigkeiten zusammen so dass sie einfach auf andere Systeme portiert werden können
            \item definiert schnittstelle
            \item Läuft als Teil des Betriebssystems
            \item Software kann auch "bare metal" oder in hypervisor virtuelle machine ausgeführt werden
        \end{notes}
        \item Hypervisor:
        \begin{notes}
            \item Virtuelle Machine manager
            \item Jede Anwendung läuft im eigenen virtuellen OS (guest)
            \item Anwendung hat ggf. keine Information darüber dass es in virtuellen Umgebung läuft
            \item jede Anwendung läuft getrennt in eigenem Runtime Umgebung
            \item 
        \end{notes}
    \end{notes}
\end{notes} 