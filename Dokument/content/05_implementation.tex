\chapter{Implementierung}

Dieses Kapitel beschreibt die Implementierung von Runtime Node und Master und vergleicht die Scheduling-Methoden.

\section{Implementierung Runtime Node}

Die Runtime Node Komponente wird auf Fahrzeugsteuergeräten ausgeführt, deren Anforderungen bei der Implementierung berücksichtigt werden müssen. Die Wahl der für die Implementierung verwendeten Programmiersprache sollte so erfolgen, dass eine möglichst hohe Kompatibilität mit den benötigten Softwarebibliotheken besteht und eine Kompilierbarkeit auf möglichst vielen Hardwarearchitekturen gegeben ist. In der \autoref{Methode Softwareplattform und Scheduling} wurde festgelegt, dass die Runtime Node Linux-Kernel-basierte Betriebssysteme voraussetzt. Der Kernel dieser Systeme ist in der Programmiersprache C implementiert. Im Vergleich zu anderen weit verbreiteten Programmiersprachen wie C++, Java, Python oder Rust ist C näher an der Hardware. Gängige C-Compiler wie GCC, Clang/LLVM oder MSVC unterstützen die meisten Hardwarearchitekturen. Für spezialisierte Plattformen im Embedded-Bereich existiert ebenfalls sehr häufig eine C-Toolchain. Aus diesem Grund eignet sich die Programmiersprache C gut als Sprache für die Implementierung des Runtime Node. Im Folgenden werden die konkreten Vorgehensweisen zur Implementierung der Softwarekomponenten des Runtime Node beschrieben.

\subsection{Implementierung der Applikationsisolierung}

Mithilfe der Applikationsisolierung werden isolierte Umgebungen für externe Anwendungen erstellt und verwaltet. Dabei kommt die Containerisierung als Isolierungsmethode zum Einsatz. Bei dieser Methode werden Linux-Kernel-Funktionen genutzt, um eine isolierte Laufzeitumgebung zu erstellen, die als Container bezeichnet wird. Die Applikationsisolierung implementiert vier Hauptfunktionen:

\begin{itemize}
    \item Container erstellen
    \item Container starten
    \item Container stoppen
    \item Container löschen
\end{itemize}

Die Erstellung eines Containers wird durch einen entsprechenden Befehl ausgelöst. In diesem muss ein Containername definiert werden, der anschließend intern zur Identifikation des Containers verwendet wird. Zunächst wird überprüft ob ein Container mit dem gleichen Namen bereits angelegt wurde. Wird der Name bereits verwendet, wird kein neuer Container erstellt und eine entsprechende Fehlermeldung an den Runtime Master kommuniziert. Existiert kein Container mit dem gleichen Namen, wird ein Ordner für den neu erstellten Container angelegt. Dieser dient als Wurzelverzeichnis für die Applikation im Container. Der Runtime Node kann eine Standardvorlage für ein Wurzelverzeichnis bereitstellen und dessen Inhalt in jeden Containerordner kopieren. Dies kann beispielweise das Wurzelverzeichnis einer Linux-Distribution beinhalten, damit die Applikationen die Standardbibliotheken und Werkzeuge eines Betriebssystems direkt nutzen können. Runtime Master kann nach Erstellung des Containers sowohl Applikationen als auch Softwarebibliotheken in den Containerordner über das Kommunikationsinterface übertragen. 

Ein Container wird gestartet, indem eine der darin vorhandenen Applikationen ausgeführt wird. Ein Container kann mehrere Applikationen beinhalten, allerdings kann der Runtime-Master aktuell nur eine Applikation pro Container starten. Ein Startbefehl für einen Container definiert dessen Namen sowie den Namen der zu startenden Applikation. Zunächst wird im Runtime-Node überprüft, ob ein Container mit dem im Startbefehl angegebenen Namen existiert. Wenn diese Voraussetzung erfüllt ist, wird überprüft, ob eine Applikationsdatei mit dem angegebenen Namen im Container vorhanden ist. Sind beide Voraussetzungen erfüllt, werden die Isolierung und das Starten der Applikationsfunktion vorbereitet. Mit der \gls{POSIX} Funktion \enquote{clone} wird eine als Parameter vorgegebene Funktion als neuer Prozess erstellt, der in den nächsten Schritten vom Betriebssystem isoliert wird. Diese \enquote{clone} Funktion unterstützt die Isolierung mittels Namespaces, indem die entsprechenden Unshare Flags, die im \autoref{Software Virtualisierung/Container} näher beschrieben wurden, als Parameter mitgegeben werden können. Die als Parameter übergeben Funktion wird also durch \enquote{clone} als neuer Prozess mit den vorgegebenen Isolierungsmaßnahmen ausgeführt. 




 Die Isolierung der Applikationen erfolgt über Linux-Kerne spezifische Funktionen. Für Unix-basierte Betriebssysteme wie Linux wurde der \gls{POSIX}-Standard entwickelt, um die Kompatibilität von Software zu erhöhen, die auf Betriebssystemfunktionen zugreift. Er definiert eine einheitliche \gls{API} für Kommandozeilen- und Shell-Funktionalität. Um die Kompatibilitätsanforderungen zu erfüllen, verwendet die Runtime Node Komponente die \gls{POSIX} \gls{API} Funktionen zur Isolierung von Anwendungen. Die \gls{API} besteht aus C Funktionen, die in der implementierten Software über die die entsprechenden header Dateien verwendet werden können. 