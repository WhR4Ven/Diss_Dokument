\chapter{Implementierung}

Dieses Kapitel beschreibt die Implementierung von Runtime Node und Master und vergleicht die Scheduling-Methoden.

\section{Implementierung Runtime Node}

Die Runtime Node Komponente wird auf Fahrzeugsteuergeräten ausgeführt, deren Anforderungen bei der Implementierung berücksichtigt werden müssen. Die Wahl der für die Implementierung verwendeten Programmiersprache sollte so erfolgen, dass eine möglichst hohe Kompatibilität mit den benötigten Softwarebibliotheken besteht und eine Kompilierbarkeit auf möglichst vielen Hardwarearchitekturen gegeben ist. In der \autoref{Methode Softwareplattform und Scheduling} wurde festgelegt, dass die Runtime Node Linux-Kernel-basierte Betriebssysteme voraussetzt. Der Kernel dieser Systeme ist in der Programmiersprache C implementiert. Im Vergleich zu anderen weit verbreiteten Programmiersprachen wie C++, Java, Python oder Rust ist C näher an der Hardware. Gängige C-Compiler wie GCC, Clang/LLVM oder MSVC unterstützen die meisten Hardwarearchitekturen. Für spezialisierte Plattformen im Embedded-Bereich existiert ebenfalls sehr häufig eine C-Toolchain. Aus diesem Grund eignet sich die Programmiersprache C gut als Sprache für die Implementierung des Runtime Node. Im Folgenden werden die konkreten Vorgehensweisen zur Implementierung der Softwarekomponenten des Runtime Node beschrieben.

\subsection{Implementierung der Applikationsisolierung}

Mithilfe der Applikationsisolierung werden isolierte Umgebungen für externe Anwendungen erstellt und verwaltet. Dabei kommt die Containerisierung als Isolierungsmethode zum Einsatz. Bei dieser Methode werden Linux-Kernel-Funktionen genutzt, um eine isolierte Laufzeitumgebung zu erstellen, die als Container bezeichnet wird. Die Applikationsisolierung implementiert vier Hauptfunktionen:

\begin{itemize}
    \item Container erstellen
    \item Container starten
    \item Container stoppen
    \item Container löschen
\end{itemize}

Die Erstellung eines Containers wird durch einen entsprechenden Befehl ausgelöst. In diesem muss ein Containername definiert werden, der anschließend intern zur Identifikation des Containers verwendet wird. Zunächst wird überprüft ob ein Container mit dem gleichen Namen bereits angelegt wurde. Wird der Name bereits verwendet, wird kein neuer Container erstellt und eine entsprechende Fehlermeldung an den Runtime Master kommuniziert. Existiert kein Container mit dem gleichen Namen, wird ein Ordner für den neu erstellten Container angelegt. Dieser dient als Wurzelverzeichnis für die Applikation im Container. Der Runtime Node kann eine Standardvorlage für ein Wurzelverzeichnis bereitstellen und dessen Inhalt in jeden Containerordner kopieren. Dies kann beispielweise das Wurzelverzeichnis einer Linux-Distribution beinhalten, damit die Applikationen die Standardbibliotheken und Werkzeuge eines Betriebssystems direkt nutzen können. Runtime Master kann nach Erstellung des Containers sowohl Applikationen als auch Softwarebibliotheken in den Containerordner über das Kommunikationsinterface übertragen. 

Die Isolierung der Applikationen erfolgt über Linux-Kerne spezifische Funktionen. Für Unix-basierte Betriebssysteme wie Linux wurde der \gls{POSIX}-Standard entwickelt, um die Kompatibilität von Software zu erhöhen, die auf Betriebssystemfunktionen zugreift. Er definiert eine einheitliche \gls{API} für Kommandozeilen- und Shell-Funktionalität. Die \gls{API} besteht aus C Funktionen, die in der implementierten Software über die die entsprechenden header Dateien verwendet werden können.  Um die Kompatibilitätsanforderungen zu erfüllen, verwendet die Runtime Node Komponente, sofern möglich, die \gls{POSIX} \gls{API} Funktionen zur Isolierung von Anwendungen. 

Ein Container wird gestartet, indem eine der darin vorhandenen Applikationen ausgeführt wird. Ein Container kann mehrere Applikationen beinhalten, allerdings kann der Runtime-Master aktuell nur eine Applikation pro Container starten. Ein Startbefehl für einen Container definiert dessen Namen sowie den Namen der zu startenden Applikation. Zunächst wird im Runtime-Node überprüft, ob ein Container mit dem im Startbefehl angegebenen Namen existiert. Wenn diese Voraussetzung erfüllt ist, wird überprüft, ob eine Applikationsdatei mit dem angegebenen Namen im Container vorhanden ist. Sind beide Voraussetzungen erfüllt, werden die Isolierung und das Starten der Applikationsfunktion vorbereitet. Mit der \gls{POSIX} Funktion \enquote{clone} wird eine als Parameter vorgegebene Funktion als neuer Prozess erstellt, der in den nächsten Schritten vom Betriebssystem isoliert wird. Diese \enquote{clone} Funktion unterstützt die Isolierung mittels Namespaces, indem die entsprechenden Unshare Flags, die im \autoref{Software Virtualisierung/Container} näher beschrieben wurden, als Parameter mitgegeben werden können. Die als Funktionsparameter übergeben Funktion wird also durch \enquote{clone} als neuer Prozess mit den vorgegebenen Isolierungsmaßnahmen ausgeführt. Die folgenden Unshare Flags werden verwendet:

\begin{itemize}
    \item CLONE\_NEWNS: Mount Namespace Unshare Flag
    \item CLONE\_NEWPID: PID Namespace Unshare Flag
    \item CLONE\_NEWUTS: IPC Namespace Unsahre Flag
    \item CLONE\_NEWNET: Network Namespace Unshare Flag
\end{itemize}

Der von der Funktion \enquote{clone} gestartete Prozess führt die Pivot-Root-Routine aus, um die Zugriffsrechte des Prozesses auf den Ordnerinhalt des Containers einzuschränken. Hierzu muss der Ordner des Containers ein Mount-Punkt des Prozesses werden. Die Systemfunktion \enquote{mount} fügt den als Parameter übergebenen Pfad als Mount-Punkt dem aktuellen Prozess hinzu. Da Pivot Root über keine \gls{POSIX}-standardisierte Wrapper-Funktion verfügt, muss es über die \enquote{syscall}-Funktion implementiert werden. Diese wird über die C-Softwarebibliothek glibc bereitgestellt, die in den meisten Linux-Distributionen enthalten ist. Abschließend wird der Prozess mit der \gls{POSIX}-Funktion \enquote{execve} durch den extern geladenen Applikation ersetzt.  Diese Applikationen werden mit allen zuvor angewendeten Isolierungsmaßnahmen im Container ausgeführt. Runtime Node erzeugt eine neue cgroup für den Prozess, sodass sowohl Systemressourcen nach Bedarf eingeschränkt werden können als auch die weiteren Prozesse, die von diesem Host-Prozess erzeugt werden, eindeutig zugeordnet werden können. Das erfolgreiche Starten der Applikation wird an den Runtime Master zurückgemeldet. 

Ein Container kann durch einen externen Befehl mit dem Namen des zu stoppenden Containers gestoppt werden. Existiert der Container mit dem Namen und wird aktuell eine Applikation ausgeführt, werden alle Prozesse im Container beendet. Hierzu genügt es, den ursprünglichen Host-Prozess zu beenden, da dieser durch die Isolierung die PID 1 erhalten hat. PID 1 wird unter Unix-Systemen als Initialisierungsprozess behandelt. Wird dieser Prozess beendet, werden alle von diesem Prozess gestarteten Prozesse ebenfalls beendet.

Container können durch den Befehl Container löschen entfernt werden. Im Befehl muss der Name des Containers angegeben werden. Existiert ein Container mit dem angegebenen Namen im Runtime-Node und führt dieser aktuell eine Anwendung aus, so wird er gestoppt und anschließend der Containerordner inklusive aller extern geladenen Dateien gelöscht.

\subsection{Implementierung des Ladens externer Applikationen}

Damit extern bereitgestellte Applikationen auf den Steuergeräten des Runtime Node ausgeführt werden können, müssen die entsprechenden Dateien auf das jeweilige Steuergerät geladen werden. Für die prototypische Implementierung wurde dasselbe Kommunikationskonzept für die Übertragung von Dateien verwendet wie für die Übertragung von Befehlen und Statusmeldungen. Die Dateien werden in vorkompilierte Form im Binärformat übertragen. Die Kommunikationsschnittstelle nutzt \gls{JSON}. Nachrichten für den Informationsaustausch. Für die Übertragung wird die folgende JSON-Struktur verwendet:

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.6\textwidth]{./content/graphics/binaryJSON.pdf}
	\caption{JSON Struktur der Binärübertrungsnachricht}
	\label{JSON binary}
\end{figure}

\gls{JSON} Nachrichten sind charakterbasiert (in der Regel UTF-8). Die Übertragung von Binärdaten im Rohformat ist nicht möglich. Binärwerte können in \gls{JSON} nur als Zeichen dargestellt werden. Eine binäre 1 würde in diesem Fall beispielsweise mit dem Zeichen 1 dargestellt werden. Diese Methode ist sehr ineffizient, da die Darstellung von einem Bit Information acht Bits benötigt. Für Anwendungen, in denen Binärdaten in textbasierten Formaten übertragen werden müssen, wurden Binär-zu-Text-Konvertierungsschemen entwickelt. In der Implementierung wurde das Base64-Schema verwendet, das im World Wide Web weit verbreitet ist, beispielsweise für die Dateiübertragung in HTML, CSS und E-Mail-Anhängen. Base64 nimmt sechs Binärwerte und repräsentiert sie mit einem von 64 Characterzeichen. Um die Kompatibilität zu erhöhen, nutzt Base64 nur ein Basisset von \gls{ASCII} Zeichen, die von den meisten Anwendungen unterstützt werden. Dadurch wird eine möglichst hohe Portierbarkeit erreicht. Insgesamt werden mit dieser Methode sechs Binärzeichen mit einem 8-Bit-Zeichen kodiert. Die übertragene Datenmenge ist somit um 33\% höher als bei der Übertragung von binären Rohdaten. 

Die Übertragungslogik ist als State Machine implementiert. Eine Dateiübertragung kann mit der in JSON dargestellten Nachricht gestartet werden, wenn das Feld \enquote{Action} den Inhalt \enquote{start\_exchange} enthält. Wenn im Feld \enquote{Binary\_Name} kein Name einer bereits existierenden Datei angegeben ist, wird eine neue Datei mit dem definierten Namen angelegt. Eine Bestätigung über das erfolgreiche Anlegen der Datei bzw. eine Fehlermeldung wird an den Runtime Master zurückgesendet. Nach einer erfolgreichen Bestätigung beginnt Runtime Master damit, die Binärdaten der Datei zu übertragen. Die Binärdaten werden Base64 kodiert im Feld \enquote{Binary\_Data} übertragen. Dieses Feld hat eine Größe von 3.076 Bytes. Durch die Base64-Kodierung sind davon allerdings nur 2.307 Bytes Nutzdaten. In der Praxis muss eine Datei in der Regel auf mehrere Pakete aufgeteilt werden. Während der Übertragung werden die empfangenen Daten dekodiert und in die erstellte Datei geschrieben. Wurden alle empfangenen Bytes erfolgreich in die Datei geschrieben, wird eine Statusmeldung an den Runtime-Master gesendet. Wurde die Datei vollständig übertragen, wird im \enquote{Action}-Feld der Inhalt \enquote{end\_exchange} gesendet. Dies signalisiert dem Runtime-Node, dass die aktuelle Datei vollständig übertragen wurde. 

\section{Implementierung der Kommunikationsschnittstelle}

Die Kommunikationsschnittstelle ist ein eigenes Softwaremodul, das ein Publish/Subscribe-Protokoll über das Netzwerk verwendet und eine sockelbasierte Schnittstelle mit JSON zu den Softwarekomponenten hin nutzt. Im \autoref{Kommunikation zwischen Fahrzeugen und Runtime Master} wurde das Kommunikationsprotokoll Publish/Subscribe und die konkrete Implementierung \gls{DDS} ausgewählt. Die Hauptaufgabe der Kommunikationsschnittstelle ist die Konvertierung zwischen \gls{DDS} und \gls{JSON} Nachrichten. Sowohl für \gls{JSON} als auch für \gls{DDS} werden Softwarebibliotheken für die Erstellung und das Versenden sowie das Auslesen von empfangenen Nachrichten verwendet. Das Kommunikationsmodul muss folglich die Nachrichtenstrukturen und die nötigen Parsing Funktionen mit den verwendeten Bibliotheken implementieren und die Daten zwischen den Strukturen konvertieren. 

In der prototypischen Umsetzung wird die \gls{DDS} Bibliothek von der Firma eProsima verwendet.  C++ kann als eine Erweiterung von C betrachtet werden. C-Code ist in der Regel auch in einer C++-Umgebung lauffähig, sodass C- und C++-Code einfach in einem Projekt kombiniert werden können. eProsima Fast DDS ist eine weit verbreitete Implementierung, die auch in \gls{ROS} 2 verwendet wird. Das Kommunikationsmodul selbst wurde ebenfalls hauptsächlich in C++ implementiert, um eine einfachere Integration mit der \gls{DDS} Bibliothek zu ermöglichen. 

Die Erstellung und Auslesen von \gls{JSON} Daten wurde mit Hilfe der Softwarebibliothek cJSON implementiert. cJSON bietet Hilfsfunktionen für die Erzeugung und das Auslesen von \gls{JSON} Daten. Der Benutzer kann mit Hilfe dieser Funktionen \gls{JSON} Strukturen selber erstellen, sowie Parsing Funktionen für definierte Strukturen implementieren. cJSON wurde in der Programmiersprache C implementiert, so dass es auch in C++ Projekte leicht integrierbar ist. 

Beim Start verbindet sich die Kommunikationsschnittstelle mit dem Kommunikationssockel von Runtime Node oder Runtime Master und startet die konfigurierten \gls{DDS} Publisher und -Subscriber. Wird eine Nachricht über einen \gls{DDS} Subscriber empfangen, werden die Daten der Nachricht in eine interne Datenstruktur kopiert. Aus dieser Struktur wird mithilfe von cJSON die entsprechende \gls{JSON} Nachricht für den Runtime Master oder den Runtime Node erstellt und über den Kommunikationssockel versendet. Umgekehrt werden aus empfangenen \gls{JSON} Nachrichten die Daten ebenfalls in die interne Datenstruktur kopiert und aus den Daten die entsprechende \gls{DDS} Nachricht mit dem dazugehörigen \gls{DDS} Publisher versendet. Das Modul ist so implementiert, dass es sowohl für den Runtime Node als auch für den Runtime Master einsetzbar ist. Dadurch müssen nicht mehrere Varianten gepflegt werden.

\section{Implementierung Runtime Master}

Die Komponente Runtime Master ist für die Verwaltung der Runtime Nodes zuständig. Sie wird nicht auf Fahrzeugsteuergeräten, sondern einmalig pro Netzwerk auf einem zentralen Server ausgeführt. Da in der Informationstechnik hauptsächlich die x86-Architektur verwendet wird, ist die Portierbarkeit auf verschiedene Hardwarearchitekturen bei dieser Komponente nicht relevant. Bei der Auswahl der Programmiersprache bestehen daher weniger Einschränkungen. Für diese Komponente wurde eine Programmiersprache ausgewählt, die eine möglichst einfache und effiziente Implementierung ermöglicht.